#
# Test opening a corrupted table.
#

-- source include/not_encrypted.inc

call mtr.add_suppression("InnoDB: Database page corruption on disk or a failed.*");
call mtr.add_suppression("InnoDB: Corruption: Block in space_id .* in file .* corrupted.");
call mtr.add_suppression("InnoDB: Based on page type .*");
call mtr.add_suppression("InnoDB: Unable to read tablespace .* page no .* into the buffer pool after .* attempts");

# Don't test under valgrind, memory leaks will occur
source include/not_valgrind.inc;
# Avoid CrashReporter popup on Mac
source include/not_crashrep.inc;
# Don't test under embedded
source include/not_embedded.inc;
# Require InnoDB
source include/have_innodb.inc;
# Require Debug for SET DEBUG
source include/have_debug.inc;
# Test could open crash reporter on Windows 
# if compiler set up
source include/not_windows.inc;

--echo # Create and populate the table to be corrupted

--disable_warnings
set global innodb_file_per_table=ON;
--enable_warnings

CREATE TABLE t1 (a INT AUTO_INCREMENT PRIMARY KEY, b TEXT) ENGINE=InnoDB;
INSERT INTO t1 (b) VALUES ('corrupt me');
--disable_query_log
--let $i = 10
while ($i)
{
  INSERT INTO t1 (b) VALUES (REPEAT('abcdefghijklmnopqrstuvwxyz', 100));
  dec $i;
}
--enable_query_log
INSERT INTO t1 (b) VALUES ('corrupt me');

let $MYSQLD_DATADIR=`select @@datadir`;
let t1_IBD = $MYSQLD_DATADIR/test/t1.ibd;
let INNODB_PAGE_SIZE=`select @@innodb_page_size`;
let MYSQLD_DATADIR=`select @@datadir`;

--source include/shutdown_mysqld.inc

--echo # Backup the t1.ibd before corrupting
--copy_file $t1_IBD $MYSQLD_DATADIR/test/t1.ibd.backup

--echo # Corrupt the table

perl;
use strict;
use warnings;
use Fcntl qw(:DEFAULT :seek);

my $ibd_file = $ENV{'t1_IBD'};

my $chunk;
my $len;

sysopen IBD_FILE, $ibd_file, O_RDWR || die "Unable to open $ibd_file";

while ($len = sysread IBD_FILE, $chunk, 1024)
{
  if ($chunk =~ s/corrupt me/korrupt me/)
  {
    print "Munged a string.\n";
    sysseek IBD_FILE, -$len, SEEK_CUR;
    syswrite IBD_FILE, $chunk, $len;
  }
}

close IBD_FILE;
EOF

--source include/start_mysqld.inc

SET DEBUG_DBUG = '+d,innodb_page_corruption_retries';

--echo # Write file to make mysql-test-run.pl expect the "crash", but don't
--echo # start it until it's told to
--exec echo "wait" > $MYSQLTEST_VARDIR/tmp/mysqld.1.expect

--echo # The below SELECT query will crash the server because some pages
--echo # on the disk are corrupted
--error 2013
SELECT * FROM t1;

# The below mtr command --remove_file fails randomly on windows with
# error number 13 which is permission denied on nix systems. We sleep
# 1 second hoping that any process holding lock on t1.ibd is released.
SLEEP 1;

--echo # Restore the original t1.ibd
--remove_file $MYSQLD_DATADIR/test/t1.ibd
--move_file $MYSQLD_DATADIR/test/t1.ibd.backup $MYSQLD_DATADIR/test/t1.ibd

--source include/start_mysqld.inc

--disable_warnings
set global innodb_file_per_table=ON;
--enable_warnings
CREATE TABLE t2 (a INT AUTO_INCREMENT PRIMARY KEY, b TEXT) ENGINE=InnoDB;
INSERT INTO t2 SELECT * FROM t1;
SELECT COUNT(*) FROM t2 where b like 'corrupt me';
DROP TABLE t1;

let t2_IBD = $MYSQLD_DATADIR/test/t2.ibd;

--source include/shutdown_mysqld.inc

--echo # Backup the t2.ibd before corrupting
--copy_file $t2_IBD $MYSQLD_DATADIR/test/t2.ibd.backup


--echo # Corrupt the table t2.ibd
perl;
use strict;
use warnings;
use Fcntl qw(:DEFAULT :seek);

my $ibd_file = $ENV{'t2_IBD'};

my $chunk;
my $len;

sysopen IBD_FILE, $ibd_file, O_RDWR || die "Unable to open $ibd_file";

while ($len = sysread IBD_FILE, $chunk, 1024)
{
  if ($chunk =~ s/corrupt me/KORRUPT ME/)
  {
    print "Munged a string.\n";
    sysseek IBD_FILE, -$len, SEEK_CUR;
    syswrite IBD_FILE, $chunk, $len;
  }
}

close IBD_FILE;
EOF

--echo # Corrupt FIL_PAGE_FILE_FLUSH_LSN_OR_KEY_VERSION field on page header

perl;
open(FILE, "+<", "$ENV{MYSQLD_DATADIR}/test/t2.ibd") or die "open";
binmode FILE;
seek(FILE, $ENV{'INNODB_PAGE_SIZE'} * 3 + 26, SEEK_SET) or die "seek";
print FILE pack("H*", "c00lcafedeadb017");
close FILE or die "close";
EOF

--source include/start_mysqld.inc

SET DEBUG_DBUG = '+d,innodb_page_corruption_retries';

--echo # Write file to make mysql-test-run.pl expect the "crash", but don't
--echo # start it until it's told to
--exec echo "wait" > $MYSQLTEST_VARDIR/tmp/mysqld.1.expect

--echo # The below SELECT query will crash the server because some pages
--echo # on the disk are corrupted
--error 2013
SELECT * FROM t2;

# The below mtr command --remove_file fails randomly on windows with
# error number 13 which is permission denied on nix systems. We sleep
# 1 second hoping that any process holding lock on t2.ibd is released.
SLEEP 1;

--echo # Restore the original t2.ibd
--remove_file $MYSQLD_DATADIR/test/t2.ibd
--move_file $MYSQLD_DATADIR/test/t2.ibd.backup $MYSQLD_DATADIR/test/t2.ibd

--source include/start_mysqld.inc

# Note SET DEBUG = '-d,innodb_page_corruption_retries' is not required
# because the session information is lost after server restart

--echo # Cleanup
DROP TABLE t2;
